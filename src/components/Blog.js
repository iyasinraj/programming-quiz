import React from 'react';

const Blog = () => {
    return (
        <div className='w-11/12 mx-auto text-justify'>
            <p className='text-center text-4xl font-bold my-5'>Blog</p>
            <div className='my-5'>
                <h1 className='text-2xl font-bold'>purpose of react router</h1>
                <p>The primary goal of Router in React JS is to supply the browser with an asynchronous URL that corresponds to the data that will show on the web page. It is mainly used to create single-page web apps since it retains the application's regular structure and functionality.The Router in React JS is primarily used to create Single Page Web Apps. In the application, React Router is utilized to define various routes. When a user enters a URL into your browser and the URL route equals one of several 'pathways' as in the router folder, the user is sent to that route.One of the prominent front-end platforms is ReactJS. Thousands of developers have utilized it for various use cases and applications. One of the most excellent features of ReactJS is that We can use it with a wide range of other technologies, including routers.</p>
            </div>
            <div className='my-5'>
                <h1 className='text-2xl font-bold'>how dose contex api works?</h1>
                <p>Context API allows data to be passed through a component tree without having to pass props manually at every level. This makes it easier to share data between components. For example, let’s say you have a shopping app with a component that shows a user’s shopping cart, and another component that shows the user’s order history. With Context API, you can create a “context” that holds the user’s shopping information, like their cart and order history. Then, you can use that context in both the shopping cart and the order history component, without having to pass the information down through props. It’s like having a big box that holds all the things you need for your shopping trip. You can take things out of the box when you need them, and put them back in when you’re done. Basically, Context API consists of two main components: the context provider and the context consumer. The provider is responsible for creating and managing the context, which holds the data to be shared between components. On the other hand, the consumer is used to access the context and its data from within a component.
                In the example given, the provider will create the context that holds the user's shopping information, while the consumer components (shopping cart and order history) will access that context to retrieve the data they need. This avoids the need to pass the information down through props, making your code more efficient and easier to manage.</p>
            </div>
            <div className='my-5'>
                <h1 className='text-2xl font-bold'>useRef hook</h1>
                <p>useRef is a hook introduced with other hooks in React version 16.8 and is mainly used for creating a reference of the DOM element or directly accessing it inside a functional component. But don't think even for a second that it's the only thing this hook is capable of as it can even be used for storing mutable values across different rerenders of the component. 
                Like every other hook in React, we have to first import this hook at the very top level as per the rules of hooks and then only we can use it in our apps. Unlike other hooks like useState which returns two values, the state and a function, this hook returns a mutable ref object which will carry the value throughout the component and if any change is made in the component, the updated value will be carried forward across our React component. This object has a property called current which will initially contain the value with which we have initialized the component. Here we have made a counter app in which we have a counter whose value increases as we click on the update function button, which triggers the function using the onClick event handler and increases the value of the encounter by one. But here is a problem, with every state change, the value of the counter gets increased on our screen, but the counter we made as an instance of the app and displayed its result in the console will stay at 1. This is because the whole app gets re-rendered with every state change making the value of the counter of the console restart with zero every time. Now let's modify this instance variable using useRef. And now, the same returned object will always be used and stay closed to the Component for the full lifetime of the component as all the mutable ref values will persist with every render. useRef doesn’t notify us when its content changes. Mutating the .current property doesn’t cause a re-render. If we want to run some code when React attaches or detaches a ref to a DOM node, a callback ref is better suited.</p>
            </div>
        </div>
    );
};

export default Blog;